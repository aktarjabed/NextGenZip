package com.aktarjabed.nextgenzip.security

import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File

object MalwareDetectionService {
    private const val TAG = "MalwareDetection"

    sealed class ScanResult {
        data class Safe(val file: String, val confidence: Float = 100f) : ScanResult()
        data class Suspicious(
            val file: String,
            val threats: List<ThreatInfo>,
            val riskScore: Float
        ) : ScanResult()
        data class Malware(
            val file: String,
            val malwareType: String,
            val severity: Severity
        ) : ScanResult()
        data class Error(val message: String) : ScanResult()
    }

    data class ThreatInfo(
        val name: String,
        val category: String,
        val confidence: Float
    )

    enum class Severity {
        CRITICAL, HIGH, MEDIUM, LOW, UNKNOWN
    }

    suspend fun scanFileLocal(file: File): ScanResult {
        return withContext(Dispatchers.IO) {
            try {
                if (!file.exists()) {
                    return@withContext ScanResult.Error("File not found: ${file.path}")
                }

                val threats = mutableListOf<ThreatInfo>()

                // Check blacklisted extensions
                if (isBlacklistedExtension(file)) {
                    threats.add(ThreatInfo(
                        name = "Suspicious Extension",
                        category = "File Type",
                        confidence = 0.85f
                    ))
                }

                // Check file size
                if (isSuspiciousSize(file)) {
                    threats.add(ThreatInfo(
                        name = "Suspicious File Size",
                        category = "Size Anomaly",
                        confidence = 0.60f
                    ))
                }

                // Check for embedded executables
                if (containsEmbeddedExecutable(file)) {
                    threats.add(ThreatInfo(
                        name = "Embedded Executable",
                        category = "Executable",
                        confidence = 0.95f
                    ))
                }

                // Check file signature
                if (isSignatureSuspicious(file)) {
                    threats.add(ThreatInfo(
                        name = "Invalid File Signature",
                        category = "Signature",
                        confidence = 0.90f
                    ))
                }

                return@withContext when {
                    threats.isEmpty() -> {
                        Log.i(TAG, "File ${file.name} is safe")
                        ScanResult.Safe(file.name, 100f)
                    }
                    threats.any { it.confidence > 0.90f } -> {
                        ScanResult.Malware(
                            file = file.name,
                            malwareType = threats.maxByOrNull { it.confidence }?.name ?: "Unknown",
                            severity = Severity.CRITICAL
                        )
                    }
                    else -> {
                        val riskScore = threats.map { it.confidence }.average().toFloat()
                        ScanResult.Suspicious(
                            file = file.name,
                            threats = threats,
                            riskScore = riskScore
                        )
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Scan error: ${e.message}")
                ScanResult.Error(e.message ?: "Unknown error")
            }
        }
    }

    private fun isBlacklistedExtension(file: File): Boolean {
        val dangerousExtensions = setOf(
            "exe", "dll", "sys", "bat", "cmd", "scr", "vbs", "js",
            "jar", "apk", "dex", "so", "out", "elf", "mach", "bin",
            "app", "msi", "psm1", "ps1", "psc1", "psc2", "msh",
            "msh1", "msh2", "mshxml", "msh1xml", "msh2xml"
        )
        val ext = file.extension.lowercase()
        return ext in dangerousExtensions
    }

    private fun isSuspiciousSize(file: File): Boolean {
        val size = file.length()
        return when {
            size > 500 * 1024 * 1024 -> true
            size < 100 && file.extension.lowercase() in setOf("exe", "dll") -> true
            else -> false
        }
    }

    private fun containsEmbeddedExecutable(file: File): Boolean {
        return try {
            file.inputStream().use { stream ->
                val magicBytes = ByteArray(4)
                if (stream.read(magicBytes) >= 2) {
                    val hex = magicBytes.take(2).joinToString("") { "%02x".format(it) }
                    hex in setOf("4d5a", "7f45", "feca", "cafb")
                } else false
            }
        } catch (e: Exception) {
            false
        }
    }

    private fun isSignatureSuspicious(file: File): Boolean {
        val signatures = mapOf(
            "zip" to byteArrayOf(0x50, 0x4B),
            "pdf" to byteArrayOf(0x25, 0x50),
            "png" to byteArrayOf(0x89.toByte(), 0x50),
            "jpg" to byteArrayOf(0xFF.toByte(), 0xD8.toByte()),
            "rar" to byteArrayOf(0x52, 0x61)
        )

        val ext = file.extension.lowercase()
        val expectedSignature = signatures[ext] ?: return false

        return try {
            file.inputStream().use { stream ->
                val actualBytes = ByteArray(2)
                stream.read(actualBytes)
                !actualBytes.take(expectedSignature.size).equals(expectedSignature.toList())
            }
        } catch (e: Exception) {
            false
        }
    }

    fun calculateRiskScore(scanResult: ScanResult): Int {
        return when (scanResult) {
            is ScanResult.Safe -> 0
            is ScanResult.Suspicious -> (scanResult.riskScore * 100).toInt().coerceIn(1, 99)
            is ScanResult.Malware -> 100
            is ScanResult.Error -> 50
        }
    }

    fun getSeverityMessage(severity: Severity): String {
        return when (severity) {
            Severity.CRITICAL -> "ðŸ”´ CRITICAL: Immediate threat detected"
            Severity.HIGH -> "ðŸŸ  HIGH: Significant threat"
            Severity.MEDIUM -> "ðŸŸ¡ MEDIUM: Requires review"
            Severity.LOW -> "ðŸ”µ LOW: Minor concern"
            Severity.UNKNOWN -> "âšª UNKNOWN: Unable to determine"
        }
    }
}
