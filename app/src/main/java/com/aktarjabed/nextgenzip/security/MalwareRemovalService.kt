package com.aktarjabed.nextgenzip.security

import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import java.util.zip.ZipOutputStream

object MalwareRemovalService {
    private const val TAG = "MalwareRemoval"

    data class SanitizationResult(
        val originalFile: String,
        val sanitizedFile: String,
        val filesRemoved: List<String>,
        val filesSafe: List<String>,
        val totalScanned: Int
    )

    data class FileThreat(
        val fileName: String,
        val signature: String,
        val severity: MalwareDetectionService.Severity
    )

    data class DeepScanResult(
        val totalFiles: Int,
        val totalSize: Long,
        val threats: List<FileThreat>,
        val isSafe: Boolean
    )

    suspend fun sanitizeZipArchive(
        zipPath: String,
        outputPath: String
    ): Result<SanitizationResult> {
        return withContext(Dispatchers.IO) {
            try {
                val zipFile = ZipFile(zipPath)
                val filesRemoved = mutableListOf<String>()
                val filesSafe = mutableListOf<String>()

                ZipOutputStream(File(outputPath).outputStream()).use { zos ->
                    zipFile.entries().iterator().forEach { entry ->
                        val fileName = entry.name

                        if (isMaliciousFile(fileName)) {
                            Log.i(TAG, "Removing malicious file: $fileName")
                            filesRemoved.add(fileName)
                        } else {
                            val data = zipFile.getInputStream(entry).readBytes()

                            val newEntry = ZipEntry(entry.name).apply {
                                time = entry.time
                                method = entry.method
                            }
                            zos.putNextEntry(newEntry)
                            zos.write(data)
                            zos.closeEntry()

                            filesSafe.add(fileName)
                        }
                    }
                }

                zipFile.close()

                Result.success(SanitizationResult(
                    originalFile = zipPath,
                    sanitizedFile = outputPath,
                    filesRemoved = filesRemoved,
                    filesSafe = filesSafe,
                    totalScanned = filesRemoved.size + filesSafe.size
                ))
            } catch (e: Exception) {
                Log.e(TAG, "Sanitization failed: ${e.message}")
                Result.failure(e)
            }
        }
    }

    suspend fun deepScanArchive(zipPath: String): Result<DeepScanResult> {
        return withContext(Dispatchers.IO) {
            try {
                val zipFile = ZipFile(zipPath)
                val threats = mutableListOf<FileThreat>()
                var totalSize = 0L

                zipFile.entries().iterator().forEach { entry ->
                    val data = zipFile.getInputStream(entry).readBytes()
                    totalSize += data.size

                    if (containsMalwareSignature(data)) {
                        threats.add(FileThreat(
                            fileName = entry.name,
                            signature = "Malware Signature",
                            severity = MalwareDetectionService.Severity.CRITICAL
                        ))
                    }

                    if (containsSuspiciousPatterns(data)) {
                        threats.add(FileThreat(
                            fileName = entry.name,
                            signature = "Suspicious Pattern",
                            severity = MalwareDetectionService.Severity.HIGH
                        ))
                    }
                }

                zipFile.close()

                Result.success(DeepScanResult(
                    totalFiles = zipFile.size(),
                    totalSize = totalSize,
                    threats = threats,
                    isSafe = threats.isEmpty()
                ))
            } catch (e: Exception) {
                Log.e(TAG, "Deep scan failed: ${e.message}")
                Result.failure(e)
            }
        }
    }

    private fun isMaliciousFile(fileName: String): Boolean {
        val maliciousPatterns = listOf(
            Regex(".*\\.(exe|dll|sys|bat|cmd|scr|vbs|js|jar|apk|dex|so)$", RegexOption.IGNORE_CASE),
            Regex("^\\.", RegexOption.IGNORE_CASE),
            Regex(".*(system32|windows|boot|driver|kernel).*", RegexOption.IGNORE_CASE),
            Regex(".*(malware|virus|trojan|spyware|ransomware).*", RegexOption.IGNORE_CASE)
        )

        return maliciousPatterns.any { pattern ->
            pattern.matches(fileName)
        }
    }

    private fun containsMalwareSignature(data: ByteArray): Boolean {
        val signatures = listOf(
            byteArrayOf(0x4D, 0x5A),
            byteArrayOf(0x7F, 0x45),
            byteArrayOf(0xCA, 0xFE.toByte())
        )

        return signatures.any { sig ->
            data.size >= sig.size && data.take(sig.size).toByteArray().contentEquals(sig)
        }
    }

    private fun containsSuspiciousPatterns(data: ByteArray): Boolean {
        val text = String(data, Charsets.UTF_8).lowercase()

        val suspiciousKeywords = listOf(
            "cmd.exe", "powershell", "registry", "regedit",
            "rundll32", "wmi", "wbem", "system32",
            "crypto", "encrypt", "wallet", "bitcoin"
        )

        return suspiciousKeywords.any { keyword ->
            text.contains(keyword)
        }
    }
}
